## Collections
Each set of data (referred to by the library as a `database`) is stored in two
collections.
A _data_ collection and a _config_ collection.

Each `database` gets a name which is then used to define the data and config collections
like so:

- `data-{name}`
- `config-{name}`

All collections are stored in the Splitgill managed MongoDB database called `sg`.

Additionally, a `status` collections is maintained with some basic information about
each `database` Splitgill is managing.

There is only one `status` collection for all the managed `databases`.

### Data Collection Model
Each document in a data collection represents one record including its current and
previous versions.

The documents are relatively simple, containing the following fields:

- `id` _(string)_ - the ID of the record
- `version` _(int)_ - the current version of the record
- `data` _(object)_ - the current data of the record
- `diffs` _(string)_ - a log of the previous versions and diffs that can incrementally
  rebuild their complete data objects using the latest data as a starting point (more on
  this below)

Each document also has an automatically assigned ID (the default MongoDB `_id` field)
which isn't used by Splitgill for any specific purpose.

#### The `version` field
The version field defines the moment in time this record's data was set to the current
value.

The version is defined as the number of milliseconds since the UNIX timestamp.
For example `22/07/23 23:55:07 UTC` is `1690070107000`.
Version numbers can only go forward in Splitgill and will be assigned by Splitgill
itself (using the current time at the moment of data storage).

#### The `data` field
This field stores a modified version of the original data presented to Splitgill by the
caller.
The code which performs these modifications is located in the
`splitgill.diffing.prepare` function.

The data must be a passed to Splitgill as a dict whereby it will then be passed
through this prepare function, before being diffed (if necessary) and stored in MongoDB.
The data is modified in this way to sanitise it and provide consistent uniformity when
diffing and patching (this process also only uses immutable types which increases
performance).

If the data field's value is an empty dict then this means the record has been deleted.

#### The `diffs` field
This field contains the previous versions of the record data as diffs that can be
applied to the current data incrementally to recreate these old versions.
The diffs are generated by the `splitgill.diffing.diff` function and can then be applied
using the `splitgill.diffing.patch` function.
Each diff is associated with the version it can recreate.

The diffs allow the recreation of each version of the data at the version the diff
represents.
To achieve this, the diffs have to be applied in reverse version order from most recent
to oldest.
The diffs have to be applied incrementally, they can only recreate the version by being
applied to the data from the next version.
For example, if there is a record with the versions 1, 4, 5, and 10.
To rebuild the data for version 1:

- patch current data (version 10) with version 5 diff
- patch result of previous step with version 4 diff
- patch result of previous step with version 1 diff
